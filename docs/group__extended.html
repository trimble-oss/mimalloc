<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mi-malloc: Extended Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mimalloc-doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="mimalloc-logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname">mi-malloc<span id="projectnumber">&#160;v1.9,  v2.2,  v3.2</span>
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__extended.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Topics</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Extended Functions</div></div>
</div><!--header-->
<div class="contents">

<p>Extended functionality.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Topics</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stats.html">Statistics</a></td></tr>
<tr class="memdesc:group__stats"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out allocation statistics. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__options.html">Runtime Options</a></td></tr>
<tr class="memdesc:group__options"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__theap.html">Thread-local heaps</a></td></tr>
<tr class="memdesc:group__theap"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>v3</b>: Thread local heaps. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix.html">Posix</a></td></tr>
<tr class="memdesc:group__posix"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpp.html">C++ wrappers</a></td></tr>
<tr class="memdesc:group__cpp"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga1ea64283508718d9d645c38efc2f4305" id="r_ga1ea64283508718d9d645c38efc2f4305"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1ea64283508718d9d645c38efc2f4305">MI_SMALL_SIZE_MAX</a></td></tr>
<tr class="memdesc:ga1ea64283508718d9d645c38efc2f4305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size allowed for small allocations in <a class="el" href="#ga7f050bc6b897da82692174f5fce59cde" title="Allocate a small object.">mi_malloc_small</a> and <a class="el" href="#ga51c47637e81df0e2f13a2d7a2dec123e" title="Allocate a zero initialized small object.">mi_zalloc_small</a> (usually <code>128*sizeof(void*)</code> (= 1KB on 64-bit systems))  <br /></td></tr>
<tr class="separator:ga1ea64283508718d9d645c38efc2f4305"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga292a45f7dbc7cd23c5352ce1f0002816" id="r_ga292a45f7dbc7cd23c5352ce1f0002816"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga292a45f7dbc7cd23c5352ce1f0002816">mi_deferred_free_fun</a>(bool force, unsigned long long heartbeat, void *arg)</td></tr>
<tr class="memdesc:ga292a45f7dbc7cd23c5352ce1f0002816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of deferred free functions.  <br /></td></tr>
<tr class="separator:ga292a45f7dbc7cd23c5352ce1f0002816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf31cea7d0332a81c8b882cbbdbadb8d" id="r_gadf31cea7d0332a81c8b882cbbdbadb8d"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadf31cea7d0332a81c8b882cbbdbadb8d">mi_output_fun</a>(const char *msg, void *arg)</td></tr>
<tr class="memdesc:gadf31cea7d0332a81c8b882cbbdbadb8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of output functions.  <br /></td></tr>
<tr class="separator:gadf31cea7d0332a81c8b882cbbdbadb8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83fc6a688b322261e1c2deab000b0591" id="r_ga83fc6a688b322261e1c2deab000b0591"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga83fc6a688b322261e1c2deab000b0591">mi_error_fun</a>(int err, void *arg)</td></tr>
<tr class="memdesc:ga83fc6a688b322261e1c2deab000b0591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of error callback functions.  <br /></td></tr>
<tr class="separator:ga83fc6a688b322261e1c2deab000b0591"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae9ddddcf14a58d0224ef3c8778e5b057" id="r_gae9ddddcf14a58d0224ef3c8778e5b057"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae9ddddcf14a58d0224ef3c8778e5b057">mi_version</a> (void)</td></tr>
<tr class="memdesc:gae9ddddcf14a58d0224ef3c8778e5b057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the mimalloc version.  <br /></td></tr>
<tr class="separator:gae9ddddcf14a58d0224ef3c8778e5b057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga421430e2226d7d468529cec457396756" id="r_ga421430e2226d7d468529cec457396756"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga421430e2226d7d468529cec457396756">mi_collect</a> (bool force)</td></tr>
<tr class="memdesc:ga421430e2226d7d468529cec457396756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eagerly free memory.  <br /></td></tr>
<tr class="separator:ga421430e2226d7d468529cec457396756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada899104276aac52539eb4de7c020f1f" id="r_gada899104276aac52539eb4de7c020f1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gada899104276aac52539eb4de7c020f1f">mi_thread_set_in_threadpool</a> (void)</td></tr>
<tr class="memdesc:gada899104276aac52539eb4de7c020f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>v3</b>: Communicate that a thread is in a threadpool.  <br /></td></tr>
<tr class="separator:gada899104276aac52539eb4de7c020f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad25050b19f30cd79397b227e0157a3f" id="r_gaad25050b19f30cd79397b227e0157a3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaad25050b19f30cd79397b227e0157a3f">mi_is_redirected</a> ()</td></tr>
<tr class="memdesc:gaad25050b19f30cd79397b227e0157a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the C runtime <em>malloc</em> API redirected?  <br /></td></tr>
<tr class="separator:gaad25050b19f30cd79397b227e0157a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8e73efc2cbca9ebfdfb166983a04c17" id="r_gaf8e73efc2cbca9ebfdfb166983a04c17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf8e73efc2cbca9ebfdfb166983a04c17">mi_thread_init</a> (void)</td></tr>
<tr class="memdesc:gaf8e73efc2cbca9ebfdfb166983a04c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize mimalloc on a thread.  <br /></td></tr>
<tr class="separator:gaf8e73efc2cbca9ebfdfb166983a04c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ae4581e85453456a0d658b2b98bf7bf" id="r_ga0ae4581e85453456a0d658b2b98bf7bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0ae4581e85453456a0d658b2b98bf7bf">mi_thread_done</a> (void)</td></tr>
<tr class="memdesc:ga0ae4581e85453456a0d658b2b98bf7bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uninitialize mimalloc on a thread.  <br /></td></tr>
<tr class="separator:ga0ae4581e85453456a0d658b2b98bf7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecfcd3ed90af99932670d881de1fa8f1" id="r_gaecfcd3ed90af99932670d881de1fa8f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaecfcd3ed90af99932670d881de1fa8f1">mi_options_print</a> (void)</td></tr>
<tr class="memdesc:gaecfcd3ed90af99932670d881de1fa8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out all runtime parameters for mimalloc.  <br /></td></tr>
<tr class="separator:gaecfcd3ed90af99932670d881de1fa8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dd50c7533baec4cc6c1a2e9adf05dd2" id="r_ga1dd50c7533baec4cc6c1a2e9adf05dd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1dd50c7533baec4cc6c1a2e9adf05dd2">mi_options_print_out</a> (<a class="el" href="#gadf31cea7d0332a81c8b882cbbdbadb8d">mi_output_fun</a> *out, void *arg)</td></tr>
<tr class="memdesc:ga1dd50c7533baec4cc6c1a2e9adf05dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out all process info.  <br /></td></tr>
<tr class="separator:ga1dd50c7533baec4cc6c1a2e9adf05dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3460a6ca91af97be4058f523d3cb8ece" id="r_ga3460a6ca91af97be4058f523d3cb8ece"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3460a6ca91af97be4058f523d3cb8ece">mi_register_deferred_free</a> (<a class="el" href="#ga292a45f7dbc7cd23c5352ce1f0002816">mi_deferred_free_fun</a> *deferred_free, void *arg)</td></tr>
<tr class="memdesc:ga3460a6ca91af97be4058f523d3cb8ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a deferred free function.  <br /></td></tr>
<tr class="separator:ga3460a6ca91af97be4058f523d3cb8ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5b17ff027cd2150b43a33040250cf3f" id="r_gae5b17ff027cd2150b43a33040250cf3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae5b17ff027cd2150b43a33040250cf3f">mi_register_output</a> (<a class="el" href="#gadf31cea7d0332a81c8b882cbbdbadb8d">mi_output_fun</a> *out, void *arg)</td></tr>
<tr class="memdesc:gae5b17ff027cd2150b43a33040250cf3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an output function.  <br /></td></tr>
<tr class="separator:gae5b17ff027cd2150b43a33040250cf3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1d55e0e894be240827e5d87ec3a1f45" id="r_gaa1d55e0e894be240827e5d87ec3a1f45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa1d55e0e894be240827e5d87ec3a1f45">mi_register_error</a> (<a class="el" href="#ga83fc6a688b322261e1c2deab000b0591">mi_error_fun</a> *errfun, void *arg)</td></tr>
<tr class="memdesc:gaa1d55e0e894be240827e5d87ec3a1f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an error callback function.  <br /></td></tr>
<tr class="separator:gaa1d55e0e894be240827e5d87ec3a1f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f050bc6b897da82692174f5fce59cde" id="r_ga7f050bc6b897da82692174f5fce59cde"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7f050bc6b897da82692174f5fce59cde">mi_malloc_small</a> (size_t size)</td></tr>
<tr class="memdesc:ga7f050bc6b897da82692174f5fce59cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a small object.  <br /></td></tr>
<tr class="separator:ga7f050bc6b897da82692174f5fce59cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51c47637e81df0e2f13a2d7a2dec123e" id="r_ga51c47637e81df0e2f13a2d7a2dec123e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga51c47637e81df0e2f13a2d7a2dec123e">mi_zalloc_small</a> (size_t size)</td></tr>
<tr class="memdesc:ga51c47637e81df0e2f13a2d7a2dec123e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a zero initialized small object.  <br /></td></tr>
<tr class="separator:ga51c47637e81df0e2f13a2d7a2dec123e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gae0085e6e1cf059a4eb7767e30e9991b8" id="r_gae0085e6e1cf059a4eb7767e30e9991b8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae0085e6e1cf059a4eb7767e30e9991b8">mi_heap_area_t::blocks</a></td></tr>
<tr class="memdesc:gae0085e6e1cf059a4eb7767e30e9991b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">start of the area containing heap blocks  <br /></td></tr>
<tr class="separator:gae0085e6e1cf059a4eb7767e30e9991b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae848a3e6840414891035423948ca0383" id="r_gae848a3e6840414891035423948ca0383"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae848a3e6840414891035423948ca0383">mi_heap_area_t::reserved</a></td></tr>
<tr class="memdesc:gae848a3e6840414891035423948ca0383"><td class="mdescLeft">&#160;</td><td class="mdescRight">bytes reserved for this area  <br /></td></tr>
<tr class="separator:gae848a3e6840414891035423948ca0383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab47526df656d8837ec3e97f11b83f835" id="r_gab47526df656d8837ec3e97f11b83f835"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab47526df656d8837ec3e97f11b83f835">mi_heap_area_t::committed</a></td></tr>
<tr class="memdesc:gab47526df656d8837ec3e97f11b83f835"><td class="mdescLeft">&#160;</td><td class="mdescRight">current committed bytes of this area  <br /></td></tr>
<tr class="separator:gab47526df656d8837ec3e97f11b83f835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab820302c5cd0df133eb8e51650a008b4" id="r_gab820302c5cd0df133eb8e51650a008b4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab820302c5cd0df133eb8e51650a008b4">mi_heap_area_t::used</a></td></tr>
<tr class="memdesc:gab820302c5cd0df133eb8e51650a008b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">bytes in use by allocated blocks  <br /></td></tr>
<tr class="separator:gab820302c5cd0df133eb8e51650a008b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga332a6c14d736a99699d5453a1cb04b41" id="r_ga332a6c14d736a99699d5453a1cb04b41"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga332a6c14d736a99699d5453a1cb04b41">mi_heap_area_t::block_size</a></td></tr>
<tr class="memdesc:ga332a6c14d736a99699d5453a1cb04b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">size in bytes of one block  <br /></td></tr>
<tr class="separator:ga332a6c14d736a99699d5453a1cb04b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab53664e31d7fe2564f8d42041ef75cb3" id="r_gab53664e31d7fe2564f8d42041ef75cb3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab53664e31d7fe2564f8d42041ef75cb3">mi_heap_area_t::full_block_size</a></td></tr>
<tr class="memdesc:gab53664e31d7fe2564f8d42041ef75cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">size in bytes of a full block including padding and metadata.  <br /></td></tr>
<tr class="separator:gab53664e31d7fe2564f8d42041ef75cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b7a0c92ece8daf46b558efc990ebdc1" id="r_ga2b7a0c92ece8daf46b558efc990ebdc1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2b7a0c92ece8daf46b558efc990ebdc1">mi_heap_area_t::heap_tag</a></td></tr>
<tr class="memdesc:ga2b7a0c92ece8daf46b558efc990ebdc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">heap tag associated with this area (see <em>mi_heap_new_ex</em>)  <br /></td></tr>
<tr class="separator:ga2b7a0c92ece8daf46b558efc990ebdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33938b31a75a5d39f4a27df3a7e19af6" id="r_ga33938b31a75a5d39f4a27df3a7e19af6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga33938b31a75a5d39f4a27df3a7e19af6">mi_stats_t::version</a></td></tr>
<tr class="separator:ga33938b31a75a5d39f4a27df3a7e19af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Extended functionality. </p>


<h3><a id="build" name="build"></a>Building</h3><div class="textblock">Checkout the sources from GitHub: </p><div class="fragment"><div class="line">git clone https:<span class="comment">//github.com/microsoft/mimalloc</span></div>
</div><!-- fragment --><h2>Windows</h2>
Open <code>ide/vs2022/mimalloc.sln</code> in Visual Studio 2022 and build. The <code>mimalloc-lib</code> project builds a static library (in <code>out/msvc-x64</code>), while the <code>mimalloc-override-dll</code> project builds a DLL for overriding malloc in the entire program.<h2>Linux, macOS, BSD, etc.</h2>
We use <a href="https://cmake.org"><code>cmake</code></a> as the build system:<div class="fragment"><div class="line">&gt; mkdir -p out/release</div>
<div class="line">&gt; cd out/release</div>
<div class="line">&gt; cmake ../..</div>
<div class="line">&gt; make</div>
</div><!-- fragment --><p> This builds the library as a shared (dynamic) library (<code>.so</code> or <code>.dylib</code>), a static library (<code>.a</code>), and as a single object file (<code>.o</code>).<code>&gt; sudo make install</code> (install the library and header files in <code>/usr/local/lib</code> and <code>/usr/local/include</code>)You can build the debug version which does many internal checks and maintains detailed statistics as:<div class="fragment"><div class="line">&gt; mkdir -p out/debug</div>
<div class="line">&gt; cd out/debug</div>
<div class="line">&gt; cmake -DCMAKE_BUILD_TYPE=Debug ../..</div>
<div class="line">&gt; make</div>
</div><!-- fragment -->This will name the shared library as <code>libmimalloc-debug.so</code>.Finally, you can build a <em>secure</em> version that uses guard pages, encrypted free lists, etc., as:<div class="fragment"><div class="line">&gt; mkdir -p out/secure</div>
<div class="line">&gt; cd out/secure</div>
<div class="line">&gt; cmake -DMI_SECURE=ON ../..</div>
<div class="line">&gt; make</div>
</div><!-- fragment -->This will name the shared library as <code>libmimalloc-secure.so</code>. Use <code>cmake ../.. -LH</code> to see all the available build options.The examples use the default compiler. If you like to use another, use:<div class="fragment"><div class="line">&gt; CC=clang CXX=clang++ cmake ../..</div>
</div><!-- fragment --><h2>Cmake with Visual Studio</h2>
You can also use cmake on Windows. Open a Visual Studio 2022 development prompt and invoke <code>cmake</code> with the right <a href="https://cmake.org/cmake/help/latest/generator/Visual%20Studio%2017%202022.html">generator</a> and architecture, like:<div class="fragment"><div class="line">&gt; cmake ..\.. -G <span class="stringliteral">&quot;Visual Studio 17 2022&quot;</span> -A x64 -DMI_OVERRIDE=ON</div>
</div><!-- fragment -->The cmake build type is specified when actually building, for example:<div class="fragment"><div class="line">&gt; cmake --build . --config=Release</div>
</div><!-- fragment -->You can also install the <a href="https://learn.microsoft.com/en-us/cpp/build/clang-support-msbuild?view=msvc-170#install-1">LLVM toolset</a> on Windows to build with the <code>clang-cl</code> compiler directly:<div class="fragment"><div class="line">&gt; cmake ../.. -G <span class="stringliteral">&quot;Visual Studio 17 2022&quot;</span> -T ClangCl</div>
</div><!-- fragment --><h2>Single Source</h2>
You can also directly build the single <code>src/static.c</code> file as part of your project without needing <code>cmake</code> at all. Make sure to also add the mimalloc <code>include</code> directory to the include path. </div>

<h3><a id="using" name="using"></a>Using the Library</h3><div class="textblock"><h3>Build</h3>
The preferred usage is including <code>&lt;mimalloc.h&gt;</code>, linking with the shared- or static library, and using the <code>mi_malloc</code> API exclusively for allocation. For example, </p><div class="fragment"><div class="line">gcc -o myprogram -lmimalloc myfile.c</div>
</div><!-- fragment -->mimalloc uses only safe OS calls (<code>mmap</code> and <code>VirtualAlloc</code>) and can co-exist with other allocators linked to the same program. If you use <code>cmake</code>, you can simply use: </p><div class="fragment"><div class="line">find_package(mimalloc 2.1 REQUIRED)</div>
</div><!-- fragment --><p> in your <code>CMakeLists.txt</code> to find a locally installed mimalloc. Then use either: </p><div class="fragment"><div class="line">target_link_libraries(myapp PUBLIC mimalloc)</div>
</div><!-- fragment --><p> to link with the shared (dynamic) library, or: </p><div class="fragment"><div class="line">target_link_libraries(myapp PUBLIC mimalloc-<span class="keyword">static</span>)</div>
</div><!-- fragment --><p> to link with the static library. See <code>test\CMakeLists.txt</code> for an example.<h3>C++</h3>
For best performance in C++ programs, it is also recommended to override the global <code>new</code> and <code>delete</code> operators. For convenience, mimalloc provides <a href="https://github.com/microsoft/mimalloc/blob/master/include/mimalloc-new-delete.h"><code>mimalloc-new-delete.h</code></a> which does this for you &ndash; just include it in a single(!) source file in your project.In C++, mimalloc also provides the <code><a class="el" href="group__cpp.html#structmi__stl__allocator" title="std::allocator implementation for mimalloc for use in STL containers.">mi_stl_allocator</a></code> struct which implements the <code>std::allocator</code> interface. For example: </p><div class="fragment"><div class="line">std::vector&lt;some_struct, mi_stl_allocator&lt;some_struct&gt;&gt; vec;</div>
<div class="line">vec.push_back(some_struct());</div>
</div><!-- fragment --><h3>Statistics</h3>
You can pass environment variables to print verbose messages (<code>MIMALLOC_VERBOSE=1</code>) and statistics (<code>MIMALLOC_SHOW_STATS=1</code>) (in the debug version): </p><div class="fragment"><div class="line">&gt; env MIMALLOC_SHOW_STATS=1 ./cfrac 175451865205073170563711388363</div>
<div class="line"> </div>
<div class="line">175451865205073170563711388363 = 374456281610909315237213 * 468551</div>
<div class="line"> </div>
<div class="line">subproc 0</div>
<div class="line"> blocks          peak       total     current       block      total#</div>
<div class="line">  bin S    4:    75.3 KiB    55.2 MiB     0          32   B       1.8 M    ok</div>
<div class="line">  bin S    6:    31.0 KiB   180.4 KiB     0          48   B       3.8 K    ok</div>
<div class="line">  bin S    8:    64   B      64   B       0          64   B       1        ok</div>
<div class="line">  bin S    9:   160   B     160   B       0          80   B       2        ok</div>
<div class="line">  bin S   17:     1.2 KiB     1.2 KiB     0         320   B       4        ok</div>
<div class="line">  bin S   21:   640   B       3.1 KiB     0         640   B       5        ok</div>
<div class="line">  bin S   33:     5.0 KiB     5.0 KiB     0           5.0 KiB     1        ok</div>
<div class="line"> </div>
<div class="line">  binned    :    84.2 Ki     41.5 Mi      0                                ok</div>
<div class="line">  huge      :     0           0           0                                ok</div>
<div class="line">  total     :    84.2 KiB    41.5 MiB     0</div>
<div class="line">  malloc req:                29.7 MiB</div>
<div class="line"> </div>
<div class="line"> pages           peak       total     current       block      total#</div>
<div class="line">  touched   :   152.8 KiB   152.8 KiB   152.8 KiB</div>
<div class="line">  pages     :     8          14           0                                ok</div>
<div class="line">  abandoned :     1         249           0                                ok</div>
<div class="line">  reclaima  :     0</div>
<div class="line">  reclaimf  :   249</div>
<div class="line">  reabandon :     0</div>
<div class="line">  waits     :     0</div>
<div class="line">  extended  :    38</div>
<div class="line">  retire    :    35</div>
<div class="line">  searches  :     0.7 avg</div>
<div class="line"> </div>
<div class="line"> arenas          peak       total     current       block      total#</div>
<div class="line">  reserved  :     1.0 GiB     1.0 GiB     1.0 GiB</div>
<div class="line">  committed :     4.8 MiB     4.8 MiB     4.4 MiB</div>
<div class="line">  reset     :     0</div>
<div class="line">  purged    :   385.5 Ki</div>
<div class="line">  arenas    :     1</div>
<div class="line">  rollback  :     0</div>
<div class="line">  mmaps     :     3</div>
<div class="line">  commits   :     0</div>
<div class="line">  resets    :     1</div>
<div class="line">  purges    :     2</div>
<div class="line">  guarded   :     0</div>
<div class="line">  heaps     :     1           1           1</div>
<div class="line"> </div>
<div class="line"> process         peak       total     current       block      total#</div>
<div class="line">  threads   :     1           1           1</div>
<div class="line">  numa nodes:     1</div>
<div class="line">  elapsed   :     0.553 s</div>
<div class="line">  process   : user: 0.557 s, system: 0.013 s, faults: 29, peak rss: 2.1 MiB, peak commit: 4.8 MiB</div>
</div><!-- fragment -->The above model of using the <code>mi_</code> prefixed API is not always possible though in existing programs that already use the standard malloc interface, and another option is to override the standard malloc interface completely and redirect all calls to the <em>mimalloc</em> library instead.See <a class="el" href="group__extended.html">Overriding Malloc</a> for more info. </div>

<h3><a id="environment" name="environment"></a>Environment Options</h3><div class="textblock">You can set further options either programmatically (using <a href="https://microsoft.github.io/mimalloc/group__options.html"><code>mi_option_set</code></a>), or via environment variables:<ul>
<li><code>MIMALLOC_SHOW_STATS=1</code>: show statistics when the program terminates.</li>
<li><code>MIMALLOC_VERBOSE=1</code>: show verbose messages (including statistics).</li>
<li><code>MIMALLOC_SHOW_ERRORS=1</code>: show error and warning messages.</li>
</ul>
Advanced options:<ul>
<li><code>MIMALLOC_ARENA_EAGER_COMMIT=2</code>: turns on eager commit for the large arenas (usually 1GiB) from which mimalloc allocates segments and pages. Set this to 2 (default) to only enable this on overcommit systems (e.g. Linux). Set this to 1 to enable explicitly on other systems as well (like Windows or macOS) which may improve performance (as the whole arena is committed at once). Note that eager commit only increases the commit but not the actual the peak resident set (rss) so it is generally ok to enable this.</li>
<li><code>MIMALLOC_PURGE_DELAY=N</code>: the delay in <code>N</code> milli-seconds (by default <code>1000</code> in v3) after which mimalloc will purge OS pages that are not in use. This signals to the OS that the underlying physical memory can be reused which can reduce memory fragmentation especially in long running (server) programs. Setting <code>N</code> to <code>0</code> purges immediately when a page becomes unused which can improve memory usage but also decreases performance. Setting it to <code>-1</code> disables purging completely.</li>
<li><code>MIMALLOC_PURGE_DECOMMITS=1</code>: By default "purging" memory means unused memory is decommitted (<code>MEM_DECOMMIT</code> on Windows, <code>MADV_DONTNEED</code> (which decresease rss immediately) on <code>mmap</code> systems). Set this to 0 to instead "reset" unused memory on a purge (<code>MEM_RESET</code> on Windows, generally <code>MADV_FREE</code> (which does not decrease rss immediately) on <code>mmap</code> systems). Mimalloc generally does not "free" OS memory but only "purges" OS memory, in other words, it tries to keep virtual address ranges and decommits within those ranges (to make the underlying physical memory available to other processes).</li>
</ul>
Further options for large workloads and services:<ul>
<li><code>MIMALLOC_ALLOW_THP=1</code>: By default always allow transparent huge pages (THP) on Linux systems. On Android only this is by default off. When set to <code>0</code>, THP is disabled for the process that mimalloc runs in. In mimalloc v3.2+, If enabled, mimalloc also sets the <code>MIMALLOC_MINIMAL_PURGE_SIZE</code> to 2MiB to avoid potentially breaking up transparent huge pages.</li>
<li><code>MIMALLOC_USE_NUMA_NODES=N</code>: pretend there are at most <code>N</code> NUMA nodes. If not set, the actual NUMA nodes are detected at runtime. Setting <code>N</code> to 1 may avoid problems in some virtual environments. Also, setting it to a lower number than the actual NUMA nodes is fine and will only cause threads to potentially allocate more memory across actual NUMA nodes (but this can happen in any case as NUMA local allocation is always a best effort but not guaranteed).</li>
<li><code>MIMALLOC_ALLOW_LARGE_OS_PAGES=0</code>: Set to 1 to use large OS pages (2 or 4MiB) when available; for some workloads this can significantly improve performance. However, large OS pages cannot be purged or shared with other processes so may lead to increased memory usage in some cases. Use <code>MIMALLOC_VERBOSE</code> to check if the large OS pages are enabled &ndash; usually one needs to explicitly give permissions for large OS pages (as on <a href="https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/enable-the-lock-pages-in-memory-option-windows?view=sql-server-2017">Windows</a> and <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/tuning_and_optimizing_red_hat_enterprise_linux_for_oracle_9i_and_10g_databases/sect-oracle_9i_and_10g_tuning_guide-large_memory_optimization_big_pages_and_huge_pages-configuring_huge_pages_in_red_hat_enterprise_linux_4_or_5">Linux</a>). However, sometimes the OS is very slow to reserve contiguous physical memory for large OS pages so use with care on systems that can have fragmented memory (for that reason, we generally recommend to use <code>MIMALLOC_RESERVE_HUGE_OS_PAGES</code> instead whenever possible).</li>
<li><code>MIMALLOC_RESERVE_HUGE_OS_PAGES=N</code>: where <code>N</code> is the number of 1GiB <em>huge</em> OS pages. This reserves the huge pages at startup and sometimes this can give a large (latency) performance improvement on big workloads. Usually it is better to not use <code>MIMALLOC_ALLOW_LARGE_OS_PAGES=1</code> in combination with this setting. Just like large OS pages, use with care as reserving contiguous physical memory can take a long time when memory is fragmented (but reserving the huge pages is done at startup only once). Note that we usually need to explicitly give permission for huge OS pages (as on <a href="https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/enable-the-lock-pages-in-memory-option-windows?view=sql-server-2017">Windows</a> and <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/tuning_and_optimizing_red_hat_enterprise_linux_for_oracle_9i_and_10g_databases/sect-oracle_9i_and_10g_tuning_guide-large_memory_optimization_big_pages_and_huge_pages-configuring_huge_pages_in_red_hat_enterprise_linux_4_or_5">Linux</a>)). The huge pages are usually allocated evenly among NUMA nodes. We can use <code>MIMALLOC_RESERVE_HUGE_OS_PAGES_AT=N</code> where <code>N</code> is the numa node (starting at 0) to allocate all the huge pages at a specific numa node instead.</li>
</ul>
Use caution when using <code>fork</code> in combination with either large or huge OS pages: on a fork, the OS uses copy-on-write for all pages in the original process including the huge OS pages. When any memory is now written in that area, the OS will copy the entire 1GiB huge page (or 2MiB large page) which can cause the memory usage to grow in large increments. </div>

<h3><a id="overrides" name="overrides"></a>Overriding Malloc</h3><div class="textblock">Overriding the standard <code>malloc</code> (and <code>new</code>) can be done either <em>dynamically</em> or <em>statically</em>.<h2>Dynamic override</h2>
This is the recommended way to override the standard malloc interface.<h3>Dynamic Override on Linux, BSD</h3>
On these ELF-based systems we preload the mimalloc shared library so all calls to the standard <code>malloc</code> interface are resolved to the <em>mimalloc</em> library. </p><div class="fragment"><div class="line">&gt; env LD_PRELOAD=/usr/lib/libmimalloc.so myprogram</div>
</div><!-- fragment -->You can set extra environment variables to check that mimalloc is running, like: </p><div class="fragment"><div class="line">&gt; env MIMALLOC_VERBOSE=1 LD_PRELOAD=/usr/lib/libmimalloc.so myprogram</div>
</div><!-- fragment --><p> or run with the debug version to get detailed statistics: </p><div class="fragment"><div class="line">&gt; env MIMALLOC_SHOW_STATS=1 LD_PRELOAD=/usr/lib/libmimalloc-debug.so myprogram</div>
</div><!-- fragment --><h3>Dynamic Override on MacOS</h3>
On macOS we can also preload the mimalloc shared library so all calls to the standard <code>malloc</code> interface are resolved to the <em>mimalloc</em> library. </p><div class="fragment"><div class="line">&gt; env DYLD_INSERT_LIBRARIES=/usr/lib/libmimalloc.dylib myprogram</div>
</div><!-- fragment -->Note that certain security restrictions may apply when doing this from the <a href="https://stackoverflow.com/questions/43941322/dyld-insert-libraries-ignored-when-calling-application-through-bash">shell</a>.<h3>Dynamic Override on Windows</h3>
<span id="override_on_windows">Dynamically overriding on mimalloc on Windows</span> is robust and has the particular advantage to be able to redirect all malloc/free calls that go through the (dynamic) C runtime allocator, including those from other DLL's or libraries. As it intercepts all allocation calls on a low level, it can be used reliably on large programs that include other 3rd party components. There are four requirements to make the overriding work well:<ol type="1">
<li>Use the C-runtime library as a DLL (using the <code>/MD</code> or <code>/MDd</code> switch).</li>
<li>Link your program explicitly with the <code>mimalloc.lib</code> export library for the <code>mimalloc.dll</code>. (which must be compiled with <code>-DMI_OVERRIDE=ON</code>, which is the default though). To ensure the <code>mimalloc.dll</code> is actually loaded at run-time it is easiest to insert some call to the mimalloc API in the <code>main</code> function, like <code><a class="el" href="#gae9ddddcf14a58d0224ef3c8778e5b057" title="Return the mimalloc version.">mi_version()</a></code> (or use the <code>/include:mi_version</code> switch on the linker command, or similarly, <code>#pragma comment(linker, "/include:mi_version")</code> in some source file). See the <code>mimalloc-test-override</code> project for an example on how to use this.</li>
<li>The <code>mimalloc-redirect.dll</code> must be put in the same directory as the main <code>mimalloc.dll</code> at runtime (as it is a dependency of that DLL). The redirection DLL ensures that all calls to the C runtime malloc API get redirected to mimalloc functions (which reside in <code>mimalloc.dll</code>).</li>
<li>Ensure the <code>mimalloc.dll</code> comes as early as possible in the import list of the final executable (so it can intercept all potential allocations). You can use <code>minject -l &lt;exe&gt;</code> to check this if needed.</li>
</ol>
For best performance on Windows with C++, it is also recommended to also override the <code>new</code>/<code>delete</code> operations (by including <a href="include/mimalloc-new-delete.h"><code>mimalloc-new-delete.h</code></a> a single(!) source file in your project).The environment variable <code>MIMALLOC_DISABLE_REDIRECT=1</code> can be used to disable dynamic overriding at run-time. Use <code>MIMALLOC_VERBOSE=1</code> to check if mimalloc was successfully redirected.For different platforms than x64, you may need a specific [redirection dll](bin). Furthermore, we cannot always re-link an executable or ensure <code>mimalloc.dll</code> comes first in the import table. In such cases the [<code>minject</code>](bin) tool can be used to patch the executable's import tables.<h2>Static override</h2>
On Unix-like systems, you can also statically link with <em>mimalloc</em> to override the standard malloc interface. The recommended way is to link the final program with the <em>mimalloc</em> single object file (<code>mimalloc.o</code>). We use an object file instead of a library file as linkers give preference to that over archives to resolve symbols. To ensure that the standard malloc interface resolves to the <em>mimalloc</em> library, link it as the first object file. For example: </p><div class="fragment"><div class="line">&gt; gcc -o myprogram mimalloc.o  myfile1.c ...</div>
</div><!-- fragment -->Another way to override statically that works on all platforms, is to link statically to mimalloc (as shown in the introduction) and include a header file in each source file that re-defines <code>malloc</code> etc. to <code>mi_malloc</code>. This is provided by <a href="https://github.com/microsoft/mimalloc/blob/master/include/mimalloc-override.h"><code>mimalloc-override.h</code></a>. This only works reliably though if all sources are under your control or otherwise mixing of pointers from different heaps may occur!<h2>List of Overrides:</h2>
The specific functions that get redirected to the <em>mimalloc</em> library are:<div class="fragment"><div class="line"><span class="comment">// C</span></div>
<div class="line"><span class="keywordtype">void</span>*  malloc(<span class="keywordtype">size_t</span> size);</div>
<div class="line"><span class="keywordtype">void</span>*  calloc(<span class="keywordtype">size_t</span> size, <span class="keywordtype">size_t</span> n);</div>
<div class="line"><span class="keywordtype">void</span>*  realloc(<span class="keywordtype">void</span>* p, <span class="keywordtype">size_t</span> newsize);</div>
<div class="line"><span class="keywordtype">void</span>   free(<span class="keywordtype">void</span>* p);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span>*  aligned_alloc(<span class="keywordtype">size_t</span> alignment, <span class="keywordtype">size_t</span> size);</div>
<div class="line"><span class="keywordtype">char</span>*  strdup(<span class="keyword">const</span> <span class="keywordtype">char</span>* s);</div>
<div class="line"><span class="keywordtype">char</span>*  strndup(<span class="keyword">const</span> <span class="keywordtype">char</span>* s, <span class="keywordtype">size_t</span> n);</div>
<div class="line"><span class="keywordtype">char</span>*  realpath(<span class="keyword">const</span> <span class="keywordtype">char</span>* fname, <span class="keywordtype">char</span>* resolved_name);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// C++</span></div>
<div class="line"><span class="keywordtype">void</span>   <span class="keyword">operator</span> <span class="keyword">delete</span>(<span class="keywordtype">void</span>* p);</div>
<div class="line"><span class="keywordtype">void</span>   <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keywordtype">void</span>* p);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span>*  <span class="keyword">operator</span> <span class="keyword">new</span>(std::size_t n) <span class="keyword">noexcept</span>(<span class="keyword">false</span>);</div>
<div class="line"><span class="keywordtype">void</span>*  <span class="keyword">operator</span> <span class="keyword">new</span>[](std::size_t n) <span class="keyword">noexcept</span>(<span class="keyword">false</span>);</div>
<div class="line"><span class="keywordtype">void</span>*  <span class="keyword">operator</span> <span class="keyword">new</span>( std::size_t n, std::align_val_t align) <span class="keyword">noexcept</span>(<span class="keyword">false</span>);</div>
<div class="line"><span class="keywordtype">void</span>*  <span class="keyword">operator</span> <span class="keyword">new</span>[]( std::size_t n, std::align_val_t align) <span class="keyword">noexcept</span>(<span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span>*  <span class="keyword">operator</span> <span class="keyword">new</span>  ( std::size_t count, <span class="keyword">const</span> std::nothrow_t&amp; tag);</div>
<div class="line"><span class="keywordtype">void</span>*  <span class="keyword">operator</span> <span class="keyword">new</span>[]( std::size_t count, <span class="keyword">const</span> std::nothrow_t&amp; tag);</div>
<div class="line"><span class="keywordtype">void</span>*  <span class="keyword">operator</span> <span class="keyword">new</span>  ( std::size_t count, std::align_val_t al, <span class="keyword">const</span> std::nothrow_t&amp;);</div>
<div class="line"><span class="keywordtype">void</span>*  <span class="keyword">operator</span> <span class="keyword">new</span>[]( std::size_t count, std::align_val_t al, <span class="keyword">const</span> std::nothrow_t&amp;);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Posix</span></div>
<div class="line"><span class="keywordtype">int</span>    posix_memalign(<span class="keywordtype">void</span>** p, <span class="keywordtype">size_t</span> alignment, <span class="keywordtype">size_t</span> size);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Linux</span></div>
<div class="line"><span class="keywordtype">void</span>*  memalign(<span class="keywordtype">size_t</span> alignment, <span class="keywordtype">size_t</span> size);</div>
<div class="line"><span class="keywordtype">void</span>*  valloc(<span class="keywordtype">size_t</span> size);</div>
<div class="line"><span class="keywordtype">void</span>*  pvalloc(<span class="keywordtype">size_t</span> size);</div>
<div class="line"><span class="keywordtype">size_t</span> malloc_usable_size(<span class="keywordtype">void</span> *p);</div>
<div class="line"><span class="keywordtype">void</span>*  reallocf(<span class="keywordtype">void</span>* p, <span class="keywordtype">size_t</span> newsize);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// macOS</span></div>
<div class="line"><span class="keywordtype">void</span>   vfree(<span class="keywordtype">void</span>* p);</div>
<div class="line"><span class="keywordtype">size_t</span> malloc_size(<span class="keyword">const</span> <span class="keywordtype">void</span>* p);</div>
<div class="line"><span class="keywordtype">size_t</span> malloc_good_size(<span class="keywordtype">size_t</span> size);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// BSD</span></div>
<div class="line"><span class="keywordtype">void</span>*  reallocarray( <span class="keywordtype">void</span>* p, <span class="keywordtype">size_t</span> count, <span class="keywordtype">size_t</span> size );</div>
<div class="line"><span class="keywordtype">void</span>*  reallocf(<span class="keywordtype">void</span>* p, <span class="keywordtype">size_t</span> newsize);</div>
<div class="line"><span class="keywordtype">void</span>   cfree(<span class="keywordtype">void</span>* p);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// NetBSD</span></div>
<div class="line"><span class="keywordtype">int</span>    reallocarr(<span class="keywordtype">void</span>* p, <span class="keywordtype">size_t</span> count, <span class="keywordtype">size_t</span> size);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Windows</span></div>
<div class="line"><span class="keywordtype">void</span>*  _expand(<span class="keywordtype">void</span>* p, <span class="keywordtype">size_t</span> newsize);</div>
<div class="line"><span class="keywordtype">size_t</span> _msize(<span class="keywordtype">void</span>* p);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span>*  _malloc_dbg(<span class="keywordtype">size_t</span> size, <span class="keywordtype">int</span> block_type, <span class="keyword">const</span> <span class="keywordtype">char</span>* fname, <span class="keywordtype">int</span> line);</div>
<div class="line"><span class="keywordtype">void</span>*  _realloc_dbg(<span class="keywordtype">void</span>* p, <span class="keywordtype">size_t</span> newsize, <span class="keywordtype">int</span> block_type, <span class="keyword">const</span> <span class="keywordtype">char</span>* fname, <span class="keywordtype">int</span> line);</div>
<div class="line"><span class="keywordtype">void</span>*  _calloc_dbg(<span class="keywordtype">size_t</span> count, <span class="keywordtype">size_t</span> size, <span class="keywordtype">int</span> block_type, <span class="keyword">const</span> <span class="keywordtype">char</span>* fname, <span class="keywordtype">int</span> line);</div>
<div class="line"><span class="keywordtype">void</span>*  _expand_dbg(<span class="keywordtype">void</span>* p, <span class="keywordtype">size_t</span> size, <span class="keywordtype">int</span> block_type, <span class="keyword">const</span> <span class="keywordtype">char</span>* fname, <span class="keywordtype">int</span> line);</div>
<div class="line"><span class="keywordtype">size_t</span> _msize_dbg(<span class="keywordtype">void</span>* p, <span class="keywordtype">int</span> block_type);</div>
<div class="line"><span class="keywordtype">void</span>   _free_dbg(<span class="keywordtype">void</span>* p, <span class="keywordtype">int</span> block_type);</div>
</div><!-- fragment --> </div>

<h3><a id="modes" name="modes"></a>Build Modes</h3><div class="textblock">We can build mimalloc in various modes.<h2>Secure Mode</h2>
<em>mimalloc</em> can be build in secure mode by using the <code>-DMI_SECURE=ON</code> flags in <code>cmake</code>. This build enables various mitigations to make mimalloc more robust against exploits. In particular:<ul>
<li>All internal mimalloc pages are surrounded by guard pages and the heap metadata is behind a guard page as well (so a buffer overflow exploit cannot reach into the metadata).</li>
<li>All free list pointers are <a href="https://github.com/microsoft/mimalloc/blob/783e3377f79ee82af43a0793910a9f2d01ac7863/include/mimalloc-internal.h#L396">encoded</a> with per-page keys which is used both to prevent overwrites with a known pointer, as well as to detect heap corruption.</li>
<li>Double free's are detected (and ignored).</li>
<li>The free lists are initialized in a random order and allocation randomly chooses between extension and reuse within a page to mitigate against attacks that rely on a predicable allocation order. Similarly, the larger heap blocks allocated by mimalloc from the OS are also address randomized.</li>
</ul>
As always, evaluate with care as part of an overall security strategy as all of the above are mitigations but not guarantees.<h2>Debug Mode</h2>
When <em>mimalloc</em> is built using debug mode, (<code>-DCMAKE_BUILD_TYPE=Debug</code>), various checks are done at runtime to catch development errors.<ul>
<li>Statistics are maintained in detail for each object size. They can be shown using <code>MIMALLOC_SHOW_STATS=1</code> at runtime.</li>
<li>All objects have padding at the end to detect (byte precise) heap block overflows.</li>
<li>Double free's, and freeing invalid heap pointers are detected.</li>
<li>Corrupted free-lists and some forms of use-after-free are detected.</li>
</ul>
<h2>Guarded Mode</h2>
<span id="guarded"><em>mimalloc</em> can be build in guarded mode using the <code>-DMI_GUARDED=ON</code> flags in <code>cmake</code>.</span> This enables placing OS guard pages behind certain object allocations to catch buffer overflows as they occur. This can be invaluable to catch buffer-overflow bugs in large programs. However, it also means that any object allocated with a guard page takes at least 8 KiB memory for the guard page and its alignment. As such, allocating a guard page for every allocation may be too expensive both in terms of memory, and in terms of performance with many system calls. Therefore, there are various environment variables (and options) to tune this:<ul>
<li><code>MIMALLOC_GUARDED_SAMPLE_RATE=N</code>: Set the sample rate to <code>N</code> (by default 4000). This mode places a guard page behind every <code>N</code> suitable object allocations (per thread). Since the performance in guarded mode without placing guard pages is close to release mode, this can be used to enable guard pages even in production to catch latent buffer overflow bugs. Set the sample rate to <code>1</code> to guard every object, and to <code>0</code> to place no guard pages at all.</li>
<li><code>MIMALLOC_GUARDED_SAMPLE_SEED=N</code>: Start sampling at <code>N</code> (by default random). Can be used to reproduce a buffer overflow if needed.</li>
<li><code>MIMALLOC_GUARDED_MIN=N</code>, <code>MIMALLOC_GUARDED_MAX=N</code>: Minimal and maximal <em>rounded</em> object sizes for which a guard page is considered (<code>0</code> and <code>1GiB</code> respectively). If you suspect a buffer overflow occurs with an object of size 141, set the minimum and maximum to <code>148</code> and the sample rate to <code>1</code> to have all of those guarded.</li>
<li><code>MIMALLOC_GUARDED_PRECISE=1</code>: If we have an object of size 13, we would usually place it an aligned 16 bytes in front of the guard page. Using <code>MIMALLOC_GUARDED_PRECISE</code> places it exactly 13 bytes before a page so that even a 1 byte overflow is detected. This violates the C/C++ minimal alignment guarantees though so use with care. </li>
</ul>
</div>

<h3><a id="tools" name="tools"></a>Tools</h3><div class="textblock">Generally, we recommend using the standard allocator with memory tracking tools, but mimalloc can also be build to support the <a href="https://github.com/google/sanitizers/wiki/AddressSanitizer">address sanitizer</a> or the excellent <a href="https://valgrind.org/">Valgrind</a> tool. Moreover, it can be build to support Windows event tracing (<a href="https://learn.microsoft.com/en-us/windows-hardware/test/wpt/event-tracing-for-windows">ETW</a>). This has a small performance overhead but does allow detecting memory leaks and byte-precise buffer overflows directly on final executables. See also the <code>test/test-wrong.c</code> file to test with various tools.<h2>Valgrind</h2>
To build with <a href="https://valgrind.org/">valgrind</a> support, use the <code>MI_TRACK_VALGRIND=ON</code> cmake option:<div class="fragment"><div class="line">&gt; cmake ../.. -DMI_TRACK_VALGRIND=ON</div>
</div><!-- fragment -->This can also be combined with secure mode or debug mode. You can then run your programs directly under valgrind:<div class="fragment"><div class="line">&gt; valgrind &lt;myprogram&gt;</div>
</div><!-- fragment -->If you rely on overriding <code>malloc</code>/<code>free</code> by mimalloc (instead of using the <code>mi_malloc</code>/<code>mi_free</code> API directly), you also need to tell <code>valgrind</code> to not intercept those calls itself, and use:<div class="fragment"><div class="line">&gt; MIMALLOC_SHOW_STATS=1 valgrind  --soname-synonyms=somalloc=*mimalloc* -- &lt;myprogram&gt;</div>
</div><!-- fragment -->By setting the <code>MIMALLOC_SHOW_STATS</code> environment variable you can check that mimalloc is indeed used and not the standard allocator. Even though the <a href="https://valgrind.org/docs/manual/manual-core.html#opt.soname-synonyms">Valgrind option</a> is called <code>--soname-synonyms</code>, this also works when overriding with a static library or object file. To dynamically override mimalloc using <code>LD_PRELOAD</code> together with <code>valgrind</code>, use:<div class="fragment"><div class="line">&gt; valgrind --trace-children=yes --soname-synonyms=somalloc=*mimalloc* /usr/bin/env LD_PRELOAD=/usr/lib/libmimalloc.so -- &lt;myprogram&gt;</div>
</div><!-- fragment -->See also the <code>test/test-wrong.c</code> file to test with <code>valgrind</code>.Valgrind support is in its initial development &ndash; please report any issues.<h2>ASAN</h2>
To build with the address sanitizer, use the <code>-DMI_TRACK_ASAN=ON</code> cmake option:<div class="fragment"><div class="line">&gt; cmake ../.. -DMI_TRACK_ASAN=ON</div>
</div><!-- fragment -->This can also be combined with secure mode or debug mode. You can then run your programs as:'<div class="fragment"><div class="line">&gt; ASAN_OPTIONS=verbosity=1 &lt;myprogram&gt;</div>
</div><!-- fragment -->When you link a program with an address sanitizer build of mimalloc, you should generally compile that program too with the address sanitizer enabled. For example, assuming you build mimalloc in <code>out/debug</code>:<div class="fragment"><div class="line">clang -g -o test-wrong -Iinclude test/test-wrong.c out/debug/libmimalloc-asan-debug.a -lpthread -fsanitize=address -fsanitize-recover=address</div>
</div><!-- fragment -->Since the address sanitizer redirects the standard allocation functions, on some platforms (macOSX for example) it is required to compile mimalloc with <code>-DMI_OVERRIDE=OFF</code>. Address sanitizer support is in its initial development &ndash; please report any issues.<h2>ETW</h2>
Event tracing for Windows (<a href="https://learn.microsoft.com/en-us/windows-hardware/test/wpt/event-tracing-for-windows">ETW</a>) provides a high performance way to capture all allocations though mimalloc and analyze them later. To build with ETW support, use the <code>-DMI_TRACK_ETW=ON</code> cmake option.You can then capture an allocation trace using the Windows performance recorder (WPR), using the <code>src/prim/windows/etw-mimalloc.wprp</code> profile. In an admin prompt, you can use: </p><div class="fragment"><div class="line">&gt; wpr -start src\prim\windows\etw-mimalloc.wprp -filemode</div>
<div class="line">&gt; &lt;my_mimalloc_program&gt;</div>
<div class="line">&gt; wpr -stop &lt;my_mimalloc_program&gt;.etl</div>
</div><!-- fragment --><p> and then open <code>&lt;my_mimalloc_program&gt;.etl</code> in the Windows Performance Analyzer (WPA), or use a tool like <a href="https://github.com/xinglonghe/TraceControl">TraceControl</a> that is specialized for analyzing mimalloc traces. </div>

<h3><a id="bench" name="bench"></a>Performance</h3><div class="textblock">We tested <em>mimalloc</em> against many other top allocators over a wide range of benchmarks, ranging from various real world programs to synthetic benchmarks that see how the allocator behaves under more extreme circumstances.In our benchmarks, <em>mimalloc</em> always outperforms all other leading allocators (<em>jemalloc</em>, <em>tcmalloc</em>, <em>Hoard</em>, etc) (Jan 2021), and usually uses less memory (up to 25% more in the worst case). A nice property is that it does <em>consistently</em> well over the wide range of benchmarks.See the <a href="https://github.com/microsoft/mimalloc#Performance">Performance</a> section in the <em>mimalloc</em> repository for benchmark results, or the the technical report for detailed benchmark results. </div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga1ea64283508718d9d645c38efc2f4305" name="ga1ea64283508718d9d645c38efc2f4305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ea64283508718d9d645c38efc2f4305">&#9670;&#160;</a></span>MI_SMALL_SIZE_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MI_SMALL_SIZE_MAX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum size allowed for small allocations in <a class="el" href="#ga7f050bc6b897da82692174f5fce59cde" title="Allocate a small object.">mi_malloc_small</a> and <a class="el" href="#ga51c47637e81df0e2f13a2d7a2dec123e" title="Allocate a zero initialized small object.">mi_zalloc_small</a> (usually <code>128*sizeof(void*)</code> (= 1KB on 64-bit systems)) </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga292a45f7dbc7cd23c5352ce1f0002816" name="ga292a45f7dbc7cd23c5352ce1f0002816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga292a45f7dbc7cd23c5352ce1f0002816">&#9670;&#160;</a></span>mi_deferred_free_fun</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void mi_deferred_free_fun(bool force, unsigned long long heartbeat, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of deferred free functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">force</td><td>If <em>true</em> all outstanding items should be freed. </td></tr>
    <tr><td class="paramname">heartbeat</td><td>A monotonically increasing count. </td></tr>
    <tr><td class="paramname">arg</td><td>Argument that was passed at registration to hold extra state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga3460a6ca91af97be4058f523d3cb8ece" title="Register a deferred free function.">mi_register_deferred_free</a> </dd></dl>

</div>
</div>
<a id="ga83fc6a688b322261e1c2deab000b0591" name="ga83fc6a688b322261e1c2deab000b0591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83fc6a688b322261e1c2deab000b0591">&#9670;&#160;</a></span>mi_error_fun</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void mi_error_fun(int err, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of error callback functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>Error code (see <a class="el" href="#gaa1d55e0e894be240827e5d87ec3a1f45" title="Register an error callback function.">mi_register_error()</a> for a complete list). </td></tr>
    <tr><td class="paramname">arg</td><td>Argument that was passed at registration to hold extra state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaa1d55e0e894be240827e5d87ec3a1f45" title="Register an error callback function.">mi_register_error()</a> </dd></dl>

</div>
</div>
<a id="gadf31cea7d0332a81c8b882cbbdbadb8d" name="gadf31cea7d0332a81c8b882cbbdbadb8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf31cea7d0332a81c8b882cbbdbadb8d">&#9670;&#160;</a></span>mi_output_fun</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void mi_output_fun(const char *msg, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of output functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>Message to output. </td></tr>
    <tr><td class="paramname">arg</td><td>Argument that was passed at registration to hold extra state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gae5b17ff027cd2150b43a33040250cf3f" title="Register an output function.">mi_register_output()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga421430e2226d7d468529cec457396756" name="ga421430e2226d7d468529cec457396756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga421430e2226d7d468529cec457396756">&#9670;&#160;</a></span>mi_collect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mi_collect </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>force</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eagerly free memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">force</td><td>If <em>true</em>, aggressively return memory to the OS (can be expensive!)</td></tr>
  </table>
  </dd>
</dl>
<p>Regular code should not have to call this function. It can be beneficial in very narrow circumstances; in particular, when a long running thread allocates a lot of blocks that are freed by other threads it may improve resource usage by calling this every once in a while. </p>

</div>
</div>
<a id="gaad25050b19f30cd79397b227e0157a3f" name="gaad25050b19f30cd79397b227e0157a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad25050b19f30cd79397b227e0157a3f">&#9670;&#160;</a></span>mi_is_redirected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mi_is_redirected </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the C runtime <em>malloc</em> API redirected? </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if all malloc API calls are redirected to mimalloc.</dd></dl>
<p>Currently only used on Windows. </p>

</div>
</div>
<a id="ga7f050bc6b897da82692174f5fce59cde" name="ga7f050bc6b897da82692174f5fce59cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f050bc6b897da82692174f5fce59cde">&#9670;&#160;</a></span>mi_malloc_small()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * mi_malloc_small </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a small object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size in bytes, can be at most <a class="el" href="#ga1ea64283508718d9d645c38efc2f4305" title="Maximum size allowed for small allocations in mi_malloc_small and mi_zalloc_small (usually 128*sizeof...">MI_SMALL_SIZE_MAX</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to newly allocated memory of at least <em>size</em> bytes, or <em>NULL</em> if out of memory. This function is meant for use in run-time systems for best performance and does not check if <em>size</em> was indeed small &ndash; use with care! </dd></dl>

</div>
</div>
<a id="gaecfcd3ed90af99932670d881de1fa8f1" name="gaecfcd3ed90af99932670d881de1fa8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecfcd3ed90af99932670d881de1fa8f1">&#9670;&#160;</a></span>mi_options_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mi_options_print </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out all runtime parameters for mimalloc. </p>
<p>Also printed with <code>MIMALLOC_VERBOSE=1</code> at startup. </p>

</div>
</div>
<a id="ga1dd50c7533baec4cc6c1a2e9adf05dd2" name="ga1dd50c7533baec4cc6c1a2e9adf05dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dd50c7533baec4cc6c1a2e9adf05dd2">&#9670;&#160;</a></span>mi_options_print_out()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mi_options_print_out </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gadf31cea7d0332a81c8b882cbbdbadb8d">mi_output_fun</a> *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out all process info. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>An output function or <em>NULL</em> for the default. </td></tr>
    <tr><td class="paramname">arg</td><td>Optional argument passed to <em>out</em> (if not <em>NULL</em>) Also printed with <code>MIMALLOC_VERBOSE=1</code> at startup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaecfcd3ed90af99932670d881de1fa8f1" title="Print out all runtime parameters for mimalloc.">mi_options_print()</a> </dd></dl>

</div>
</div>
<a id="ga3460a6ca91af97be4058f523d3cb8ece" name="ga3460a6ca91af97be4058f523d3cb8ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3460a6ca91af97be4058f523d3cb8ece">&#9670;&#160;</a></span>mi_register_deferred_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mi_register_deferred_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga292a45f7dbc7cd23c5352ce1f0002816">mi_deferred_free_fun</a> *</td>          <td class="paramname"><span class="paramname"><em>deferred_free</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a deferred free function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deferred_free</td><td>Address of a deferred free-ing function or <em>NULL</em> to unregister. </td></tr>
    <tr><td class="paramname">arg</td><td>Argument that will be passed on to the deferred free function.</td></tr>
  </table>
  </dd>
</dl>
<p>Some runtime systems use deferred free-ing, for example when using reference counting to limit the worst case free time. Such systems can register (re-entrant) deferred free function to free more memory on demand. When the <em>force</em> parameter is <em>true</em> all possible memory should be freed. The per-thread <em>heartbeat</em> parameter is monotonically increasing and guaranteed to be deterministic if the program allocates deterministically. The <em>deferred_free</em> function is guaranteed to be called deterministically after some number of allocations (regardless of freeing or available free memory). At most one <em>deferred_free</em> function can be active. </p>

</div>
</div>
<a id="gaa1d55e0e894be240827e5d87ec3a1f45" name="gaa1d55e0e894be240827e5d87ec3a1f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1d55e0e894be240827e5d87ec3a1f45">&#9670;&#160;</a></span>mi_register_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mi_register_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga83fc6a688b322261e1c2deab000b0591">mi_error_fun</a> *</td>          <td class="paramname"><span class="paramname"><em>errfun</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an error callback function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errfun</td><td>The error function that is called on an error (use <em>NULL</em> for default) </td></tr>
    <tr><td class="paramname">arg</td><td>Extra argument that will be passed on to the error function.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>errfun</em> function is called on an error in mimalloc after emitting an error message (through the output function). It as always legal to just return from the <em>errfun</em> function in which case allocation functions generally return <em>NULL</em> or ignore the condition. The default function only calls abort() when compiled in secure mode with an <em>EFAULT</em> error. The possible error codes are:</p><ul>
<li><em>EAGAIN:</em> Double free was detected (only in debug and secure mode).</li>
<li><em>EFAULT:</em> Corrupted free list or meta-data was detected (only in debug and secure mode).</li>
<li><em>ENOMEM:</em> Not enough memory available to satisfy the request.</li>
<li><em>EOVERFLOW:</em> Too large a request, for example in <a class="el" href="group__malloc.html#ga6686568014b54d1e6c7ac64a076e4f56" title="Allocate zero-initialized count elements of size bytes.">mi_calloc()</a>, the <em>count</em> and <em>size</em> parameters are too large.</li>
<li><em>EINVAL:</em> Trying to free or re-allocate an invalid pointer. </li>
</ul>

</div>
</div>
<a id="gae5b17ff027cd2150b43a33040250cf3f" name="gae5b17ff027cd2150b43a33040250cf3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5b17ff027cd2150b43a33040250cf3f">&#9670;&#160;</a></span>mi_register_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mi_register_output </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gadf31cea7d0332a81c8b882cbbdbadb8d">mi_output_fun</a> *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an output function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output function, use <code>NULL</code> to output to stderr. </td></tr>
    <tr><td class="paramname">arg</td><td>Argument that will be passed on to the output function.</td></tr>
  </table>
  </dd>
</dl>
<p>The <code>out</code> function is called to output any information from mimalloc, like verbose or warning messages. </p>

</div>
</div>
<a id="ga0ae4581e85453456a0d658b2b98bf7bf" name="ga0ae4581e85453456a0d658b2b98bf7bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ae4581e85453456a0d658b2b98bf7bf">&#9670;&#160;</a></span>mi_thread_done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mi_thread_done </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uninitialize mimalloc on a thread. </p>
<p>Should not be used as on most systems (pthreads, windows) this is done automatically. Ensures that any memory that is not freed yet (but will be freed by other threads in the future) is properly handled. </p>

</div>
</div>
<a id="gaf8e73efc2cbca9ebfdfb166983a04c17" name="gaf8e73efc2cbca9ebfdfb166983a04c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8e73efc2cbca9ebfdfb166983a04c17">&#9670;&#160;</a></span>mi_thread_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mi_thread_init </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize mimalloc on a thread. </p>
<p>Should not be used as on most systems (pthreads, windows) this is done automatically. </p>

</div>
</div>
<a id="gada899104276aac52539eb4de7c020f1f" name="gada899104276aac52539eb4de7c020f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada899104276aac52539eb4de7c020f1f">&#9670;&#160;</a></span>mi_thread_set_in_threadpool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mi_thread_set_in_threadpool </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>v3</b>: Communicate that a thread is in a threadpool. </p>
<p>This is done automatically for threads in the Windows threadpool, but if using a custom threadpool it is good to call this on worker threads. Internally, mimalloc uses different locality heuristics for worker threads to try to reduce non-local accesss. </p>

</div>
</div>
<a id="gae9ddddcf14a58d0224ef3c8778e5b057" name="gae9ddddcf14a58d0224ef3c8778e5b057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9ddddcf14a58d0224ef3c8778e5b057">&#9670;&#160;</a></span>mi_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mi_version </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the mimalloc version. </p>
<dl class="section return"><dt>Returns</dt><dd>The version. For v1,v2 the version is 100*major + 10*minor + patch (for example 227 for v2.2.7). For <b>v3</b>, it is 1000*major + 100*minor + path (for example, 3207 for v3.2.7). </dd></dl>

</div>
</div>
<a id="ga51c47637e81df0e2f13a2d7a2dec123e" name="ga51c47637e81df0e2f13a2d7a2dec123e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51c47637e81df0e2f13a2d7a2dec123e">&#9670;&#160;</a></span>mi_zalloc_small()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * mi_zalloc_small </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a zero initialized small object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size in bytes, can be at most <a class="el" href="#ga1ea64283508718d9d645c38efc2f4305" title="Maximum size allowed for small allocations in mi_malloc_small and mi_zalloc_small (usually 128*sizeof...">MI_SMALL_SIZE_MAX</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to newly allocated zero-initialized memory of at least <em>size</em> bytes, or <em>NULL</em> if out of memory. This function is meant for use in run-time systems for best performance and does not check if <em>size</em> was indeed small &ndash; use with care! </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga332a6c14d736a99699d5453a1cb04b41" name="ga332a6c14d736a99699d5453a1cb04b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga332a6c14d736a99699d5453a1cb04b41">&#9670;&#160;</a></span>block_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mi_heap_area_t::block_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>size in bytes of one block </p>

</div>
</div>
<a id="gae0085e6e1cf059a4eb7767e30e9991b8" name="gae0085e6e1cf059a4eb7767e30e9991b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0085e6e1cf059a4eb7767e30e9991b8">&#9670;&#160;</a></span>blocks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* mi_heap_area_t::blocks</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>start of the area containing heap blocks </p>

</div>
</div>
<a id="gab47526df656d8837ec3e97f11b83f835" name="gab47526df656d8837ec3e97f11b83f835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab47526df656d8837ec3e97f11b83f835">&#9670;&#160;</a></span>committed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mi_heap_area_t::committed</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>current committed bytes of this area </p>

</div>
</div>
<a id="gab53664e31d7fe2564f8d42041ef75cb3" name="gab53664e31d7fe2564f8d42041ef75cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab53664e31d7fe2564f8d42041ef75cb3">&#9670;&#160;</a></span>full_block_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mi_heap_area_t::full_block_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>size in bytes of a full block including padding and metadata. </p>

</div>
</div>
<a id="ga2b7a0c92ece8daf46b558efc990ebdc1" name="ga2b7a0c92ece8daf46b558efc990ebdc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b7a0c92ece8daf46b558efc990ebdc1">&#9670;&#160;</a></span>heap_tag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mi_heap_area_t::heap_tag</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>heap tag associated with this area (see <em>mi_heap_new_ex</em>) </p>

</div>
</div>
<a id="gae848a3e6840414891035423948ca0383" name="gae848a3e6840414891035423948ca0383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae848a3e6840414891035423948ca0383">&#9670;&#160;</a></span>reserved</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mi_heap_area_t::reserved</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>bytes reserved for this area </p>

</div>
</div>
<a id="gab820302c5cd0df133eb8e51650a008b4" name="gab820302c5cd0df133eb8e51650a008b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab820302c5cd0df133eb8e51650a008b4">&#9670;&#160;</a></span>used</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mi_heap_area_t::used</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>bytes in use by allocated blocks </p>

</div>
</div>
<a id="ga33938b31a75a5d39f4a27df3a7e19af6" name="ga33938b31a75a5d39f4a27df3a7e19af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33938b31a75a5d39f4a27df3a7e19af6">&#9670;&#160;</a></span>version</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mi_stats_t::version</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
